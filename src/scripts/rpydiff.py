"""Summary

Attributes:
    indir (str): Description
    outdir (str): Description
    patchmode_default (str): Description
    rpy_preamble (TYPE): Description
    SEP (str): Description
"""
from PIL import Image
# from PIL import ImageChops
import os
import glob
import yaml
import math
import shutil

# N.B. Unlike most other scripts, this requires Python 3.8.
# If you run this with an outdated python version, you will get a SyntaxError.
# This script is entirely optional.

indir = "rpydiff_in"
outdir = "rpydiff_out"
SEP = "_"  # Seperator between char name and pose names in output files
patchmode_default = "box"

rpy_preamble = """# Automatically generated by rpydiff.py
init offset = 1
"""


def spriteLocation(char_name):
    """Formats the location of a sprite relative to a mod directory
    Should begin with {{assets}}
    
    Args:
        char_name (str): Name of the character, for formats like assets/sprites/char/pose
    
    Returns:
        str: Path to a directory
    """
    return "{{assets}}/sprites/"


for d in [indir, outdir]:
    os.makedirs(d, exist_ok=True)


def distance(t1, t2):
    """Returns the distance between two points in n-dimensional space.
    Used for determining the difference between two RGBA colors.
    Coordinate length must match.
    
    Args:
        t1 (tuple): Coordinates
        t2 (tuple): Coordinates
    
    Returns:
        float: Distance
    """
    e2 = 0
    for a, b in zip(t1, t2):
        e2 += (a - b) ** 2
    return math.sqrt(e2)


class Pose():

    """Represents a pose.
    
    Attributes:
        expression (TYPE): Renpy-safe name of expression.
        file (TYPE): File path, including input directory
        file_orig (TYPE): Original file name
        options (dict): Additional processing options
        phony (TYPE): Should this (base) pose be available?
    """
    
    def __init__(self, data, char_name="DEFAULT"):
        """Pass data from json
        """
        try:
            # Be careful with expression here!
            self.file_orig = data.get("file", f"{char_name}_{data['expression']}.png")
            self.file = os.path.join(indir, self.file_orig)

            self.expression = str(data["expression"]).replace("-", "_")
            self.options = {}
            self.phony = data.get("phony", False)
            for key in ["mode", "fuzz", "box_pad"]:
                if data.get(key):
                    self.options[key] = data.get(key)
        except (KeyError, TypeError):
            print(data)
            raise

        if not os.path.isfile(self.file):
            print(data)
            raise FileNotFoundError(self.file)

    def getImage(self):
        """
        Returns:
            PIL.Image
        """
        return Image.open(self.file).convert('RGBA')

    def __repr__(self):
        return f"<{self.expression}: {self.file} ({self.options})>"


class Patch():

    """Represents a patch image
    
    Attributes:
        bbox (tuple): Bouding box
        filename (str): Filename of output file, once saved
        good (bool): Is this patch worth using?
        image (PIL.Image): Image data
        outpath (str): Output path
        x (int): Location of leftmost pixel
        y (int): Location of rightmost pixel
    """
    
    def __init__(self, diff, x1, y1, bbox, original, updated):
        """Summary
        
        Args:
            diff (PIL.Image): Image
            x1 (int): Location of leftmost pixel
            y1 (int): Location of rightmost pixel
            bbox (tuple): Bouding box
            patch_good (bool): Is this patch worth using?
        """
        self.image = diff
        self.x = x1
        self.y = y1 
        self.bbox = bbox 
        self.good = (diff.size != original.getImage().size)
        self.outpath = None

        self.expression = f"{original.expression} {updated.expression}"

    def save(self, patch_filename):
        """Saves the batch based on its filename
        Also populates the outpath and filename attributes
        
        Args:
            patch_filename (str): Output filename
        """
        patch_out_path = os.path.join(
            outdir, 
            patch_filename
        )
        self.image.save(patch_out_path)
        self.outpath = patch_out_path
        self.filename = patch_filename
        

def getPatch(original_pose, update_pose, mode="box", fuzz=None, box_pad=2):
    """
    Compares to images and saves a diff image, if there
    is a difference
    
    Args:
        original_pose (TYPE): Description
        update_pose (TYPE): Description
        mode (str, optional): Description
        fuzz (None, optional): Description
        box_pad (int, optional): Description
    
    Returns:
        TYPE: Description
    """

    if fuzz is None:
        if mode == "load":
            fuzz = 0
        else:
            fuzz = 100
        print(f"[INFO] Fuzz not specified for mode '{mode}', using mode-default {fuzz}")

    original = original_pose.getImage()
    update = update_pose.getImage()

    # Center-align images
    if original.size != update.size:
        return None
        print("Size mismatch, re-canvasing")
        new_size = (max(original.size[0], update.size[0]), max(original.size[1], update.size[1]),)
        
        newImage = Image.new("RGBA", new_size)
        newImage.paste(srcImage, (x1,y1,x1+oldWidth,y1+oldHeight))

    # if mode == "ic":
        # from PIL import ImageChops
        # try:
        #     mask = ImageChops.difference(original, update)
        #     (x1, y1, x2, y2) = mask.getbbox()
        #     diff = update.crop((x1 - box_pad, y1 - box_pad, x2 + box_pad, y2 + box_pad,))
        # except ValueError:
        #     import traceback
        #     traceback.print_exc()
        #     print(f"{original.mode=}, {update.mode=}")
        #     return

    #     diff = mask

    if mode == "load":
        w, h = original.size

        diff = Image.new('RGBA', original.size, (255, 255, 255, 0))  # create a new transparent canvas
        pixels = diff.load()  # create the pixel map
        originalp = original.load()
        updatep = update.load()

        x1, y1 = w, h
        x2 = 0
        y2 = 0

        for x in range(w):    # for every col:
            for y in range(h):    # For every row
                op = originalp[x, y]
                up = updatep[x, y]
                if (op) != up and distance(op, up) > fuzz:
                    pixels[x, y] = up
                    x1 = min(x1, x)  
                    y1 = min(y1, y)  
                    x2 = max(x2, x + 1)
                    y2 = max(y2, y + 1)
                # print(x, y, x1, y1, x2, y2)
        diff = diff.crop((x1, y1, x2, y2,))

    elif mode == "box":
        w, h = original.size
        originalp = original.load()
        updatep = update.load()

        x1, y1 = w, h
        x2 = 0
        y2 = 0

        for x in range(w):    # for every col:
            for y in range(h):    # For every row
                op = originalp[x, y]
                up = updatep[x, y]
                if (op) != up and distance(op, up) > fuzz:
                    x1 = min(x1, x)  
                    y1 = min(y1, y)  
                    x2 = max(x2, x + 1)
                    y2 = max(y2, y + 1)
        x1 = max(x1 - box_pad, 0)  
        y1 = max(y1 - box_pad, 0)  
        x2 = min(x2 + box_pad, w)
        y2 = min(y2 + box_pad, h)
        
        diff = update.crop((x1, y1, x2, y2,))

    else:
        print(f"[ERR ] No such mode '{mode}'")

    bbox = diff.getbbox()
    if not bbox:
        return None

    # print(diff.size, original.size, bbox != original.size)

    globals().update(locals())

    return Patch(diff, x1, y1, bbox, original_pose, update_pose)


def rpyDefineComposite(char_name, base_pose, updated_pose, patch):
    """Summary
    
    Args:
        char_name (TYPE): Description
        base_pose (TYPE): Description
        updated_pose (TYPE): Description
        patch (TYPE): Description
    
    Returns:
        TYPE: Description
    """
    return f"""
image !{char_name} {patch.expression} = Composite(
    {base_pose.getImage().size},
    (0, 0), "{spriteLocation(char_name)}{base_pose.file_orig}",
    ({patch.x}, {patch.y}), "{spriteLocation(char_name)}{patch.filename}"
)
"""


def rpyDefinePassthrough(char_name, base_pose, updated_pose, patch):
    """Summary
    
    Args:
        char_name (TYPE): Description
        base_pose (TYPE): Description
        updated_pose (TYPE): Description
        patch (TYPE): Description
    
    Returns:
        TYPE: Description
    """
    if updated_pose:
        shutil.copy2(updated_pose.file, outdir)
        return f"""
image !{char_name} {patch.expression} = "{spriteLocation(char_name)}{updated_pose.file_orig}"
"""
    else:
        shutil.copy2(base_pose.file, outdir)
        return f"""
image !{char_name} {base_pose.expression} = "{spriteLocation(char_name)}{base_pose.file_orig}"
"""


def rpyDefineNodiff(char_name, base_pose, updated_pose, patch):
    """Summary
    
    Args:
        char_name (TYPE): Description
        base_pose (TYPE): Description
        updated_pose (TYPE): Description
        patch (TYPE): Description
    
    Returns:
        TYPE: Description
    """
    return f"""
image !{char_name} {updated_pose.expression} = "{spriteLocation(char_name)}{base_pose.file_orig}"
"""


def doDiff(base_pose, updated_pose, rpyfp, char_options={}):
    """Summary
    
    Args:
        base_pose (TYPE): Description
        updated_pose (TYPE): Description
        rpyfp (TYPE): Description
        char_options (dict, optional): Description
    """
    patch_options = char_options.copy()
    patch_options.update(base_pose.options)
    patch_options.update(updated_pose.options)

    print(f"[INFO] Diffing {base_pose=} against {updated_pose=} with options {patch_options}")
    patch = getPatch(
        base_pose, updated_pose,
        **patch_options
    )

    if patch:
        if patch.good:
            patch_filename = SEP.join([
                char_name, 
                patch.expression,
                f"{patch.x},{patch.y}.png"
            ])
            print(f"[INFO] Patch with bbox {patch.bbox} saved to {patch_filename}")
            patch.save(patch_filename)
            rpyfp.write(rpyDefineComposite(char_name, base_pose, updated_pose, patch))
        else:
            print("[WARN] Generated patch is not useful!")
            rpyfp.write(rpyDefinePassthrough(char_name, base_pose, updated_pose, patch))
    else:
        print(f"[WARN] No difference between images {base_pose}, {updated_pose}, adjust settings?")
        rpyfp.write(rpyDefineNodiff(char_name, base_pose, updated_pose, patch))


if __name__ == '__main__':
    for json_filepath in glob.glob(os.path.join(indir, "*.yaml")):
        with open(json_filepath, "r") as fp:
            data = yaml.safe_load(fp.read())

        for char_name, char_subdata in data.items():
            with open(os.path.join(outdir, char_name + ".rpy"), "w") as rpyfp:
                rpyfp.write(rpy_preamble)
                char_options = char_subdata.get("options", {})
                char_patches = char_subdata.get("patchsets", [])
                for patchdata in char_patches:
                    base_pose = Pose(patchdata["base"], char_name)
                    updated_poses = (Pose(pose, char_name) for pose in patchdata.get("subposes", ()))
                    if not base_pose.phony:
                        rpyfp.write(rpyDefinePassthrough(char_name, base_pose, None, None))
                    for updated_pose in updated_poses:
                        doDiff(base_pose, updated_pose, rpyfp, char_options)
